<!DOCTYPE html>
<html lang="en">

<head>
    <title>Assignment - 3</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .header {
            font-size: 4rem;
            font-weight: bold;
            background: linear-gradient(45deg, #F59E0B, #F472B6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            0% {
                text-shadow: 0 0 1px #F59E0B, 0 0 3px #F59E0B, 0 0 5px #F59E0B;
            }
            100% {
                text-shadow: 0 0 3px #F59E0B, 0 0 5px #F59E0B, 0 0 7px #F59E0B;
            }
        }
    </style>
</head>

<body class="font-sans bg-gradient-to-r from-purple-500 via-blue-500 to-green-500 text-white">

    <header class="text-white py-4 flex justify-between items-center">
        <h1 class="text-3xl font-bold text-center flex-grow header">Assignment - 3</h1>
        <button class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded mr-5" onclick="homepage()">Home</button>
    </header>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Implementation</h2>
        <p class="mb-4">The code provided below implements the N-queens problem in Python using a backtracking approach:</p>
        <pre class="bg-gray-200 p-4 rounded-md">
            <code class="block text-sm">
def solve_n_queens(N):
    def is_safe(board, row, col):
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        
        i, j = row, col
        while i >= 0 and j < N:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j += 1
        
        return True
    
    def solve(row):
        if row == N:
            solutions.append([''.join(row) for row in board])
            return
        
        for col in range(N):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                solve(row + 1)
                board[row][col] = '.'  # Backtrack
    
    board = [['.' for _ in range(N)] for _ in range(N)]
    solutions = []
    solve(0)
    return solutions

def print_solutions(solutions):
    for i, solution in enumerate(solutions):
        print(f"Solution {i + 1}:")
        for row in solution:
            print(row)
        print("\n")

solutions = solve_n_queens(N)
print_solutions(solutions)
            </code>
        </pre>
    </section>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Example Input/Output</h2>
        <p class="mb-4">When a value N is passed as input into the above code we print a chessboard layout with 'Q' as safe places and other positions as '.'</p>
        <pre class="bg-gray-200 p-4 rounded-md">
            <code class="block text-sm">
# Example usage:
N = 4

Solution 1:
.Q..
...Q
Q...
..Q.

Solution 2:
..Q.
Q...
...Q
.Q..
            </code>
        </pre>
    </section>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Time Complexity</h2>
        <p class="mb-4">The time complexity of the N-Queens problem solver is typically exponential, O(N!), as it explores all possible combinations of queen placements on the board. However, due to the pruning effect of the backtracking algorithm, the actual number of recursive calls and computations is much lower in practice, making it suitable for small chessboard sizes.</p>
    </section>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Scenarios</h2>
        <p class="text-gray-700"><strong>Efficiency:</strong> Inefficient for large values of N.</p>
        <p class="text-gray-700"><strong>Scenarios:</strong> Suitable for small chessboard sizes, educational purposes, or exploring backtracking algorithms.</p>
    </section>

    <script src="adsscript.js"></script>

</body>

</html>
